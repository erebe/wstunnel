# Restrictions are whitelist rules for the tunnels
# By default, all requests are denied and only if a restriction match, the request is allowed
restrictions:
  - name: "Allow all"
    description: "This restriction allows all requests"
    # This restriction apply only and only if all matchers match/are evaluated to true
    # It is a logical AND
    match:
      # This match apply only if it succeeds to match the path prefix with the given regex
      # The regex does a match, so if you want to match exactly you need to bound the pattern with ^ $
      # I.e: "tesotron" is going to match "XXXtesotronXXX", but "^tesotron$" is going to match only "tesotron"
      - !PathPrefix "^.*$"
      # This match applies only if it succeeds to match the Authentication Header with the given regex.
      # If present, Authentication Header must exists and must match the regex.
      # - !Authorization "^[Bb]earer +actual_bearer_token_to_match$"
      # The only other possible match type for now is !Any, that match everything/any request
      # - !Any

    # This is the list of tunnels your restriction is going to allow
    # The list is checked in order, the first match is going to allow the request
    allow:
      # !Tunnel allows forward tunnels
      - !Tunnel
        # Protocol that are allowed. Empty list means all protocols are allowed
        # Logical OR
        protocol:
          - Tcp
          - Udp
        # Port that are allowed. Can be a single port or an inclusive range (i.e. 80..90)
        # Logical OR
        port:
          - 80
          - 443
          - 8080..8089

        # if the tunnel wants to connect to a specific host, this regex must match
        host: ^.*$
        # if the tunnel wants to connect to a specific IP, it must be included in one of the network cidr
        # Logical OR
        cidr:
          - 0.0.0.0/0
          - ::/0

      # !ReverseTunnel allows reverse tunnels
      # Not specifying anything means all reverse tunnels are allowed
      - !ReverseTunnel
        protocol:
          - Tcp
          - Udp
          - Socks5
          - Unix
        port:
          - 1..65535
        # Maps ports on the server side from X to Y (X:Y). For example with 10001:8080 configured and a client
        # which connects using '-R tcp://10001:localhost:80' the server will listen on port 8080 instead of 10001.
        # The originally requested ports (NOT the mapped ports) need to be allowed via the 'ports' directive.
        port_mapping:
          - 10001:8080
        cidr:
          - 0.0.0.0/0
          - ::/0
        unix_path: "^.*$"

---
# Examples
restrictions:
  - name: "example 1"
    description: "Only allow forward tunnels to port 443 and forbid reverse tunnels"
    match:
      - !PathPrefix "^.*$"
    allow:
      - !Tunnel
        port:
          - 443
---
restrictions:
  - name: "example 2"
    description: "Only allow forward tunnels to local ssh and forbid reverse tunnels"
    match:
      - !PathPrefix "^.*$"
    allow:
      - !Tunnel
        protocol:
          - Tcp
        port:
          - 22
        host: ^localhost$
        cidr:
          - 127.0.0.1/32
---
restrictions:
  - name: "example 3"
    description: "Only allow socks5 reverse tunnels listening on port between 1080..1443 on lan network"
    match:
      - !PathPrefix "^.*$"
    allow:
      - !ReverseTunnel
        protocol:
          - Socks5
        port:
          - 1080..1443
        cidr:
          - 192.168.0.0/16
---
restrictions:
  - name: "example 4"
    description: "Allow everything for client using path prefix my-super-secret-path"
    match:
      - !PathPrefix "^my-super-secret-path$"
    allow:
      - !Tunnel
      - !ReverseTunnel
---
restrictions:
  - name: "example 5"
    description: "Forbid everything ..."
    match:
      - !Any
    allow: []
---
restrictions:
  - name: "example 6"
    description: "Allow reverse tunnel for Unix socket on /tmp/xxxx "
    match:
      - !Any
    allow:
      - !ReverseTunnel
        unix_path: "^/tmp/"

---
# Certificate-based variable substitution examples (NEW FEATURE)
# Requires mTLS authentication with client certificates
restrictions:
  # Dynamic certificate-based access control
  # Single rule handles unlimited devices based on their certificate CN
  - name: "Certificate CN-based device isolation"
    description: "Devices can only access Unix sockets matching their certificate Common Name"
    match:
      - !Any  # Match all mTLS connections
    allow:
      - !ReverseTunnel
        protocol:
          - Unix
        port:
          - 1..65535
        # Variable substitution: ${cn} is replaced with the certificate's Common Name
        # Example: Certificate CN "device001" → matches "/tmp/sockets/device001.sock"
        # Example: Certificate CN "iot-sensor-42" → matches "/tmp/sockets/iot-sensor-42.sock"
        unix_path: "^/tmp/sockets/${cn}\\.sock$"

---
restrictions:
  # Path prefix + certificate validation
  - name: "CN-based path prefix and socket access"
    description: "Require upgrade path to match CN and restrict socket access to CN-specific directory"
    match:
      # Path prefix must match the certificate CN exactly
      - !PathPrefix "^${cn}$"
    allow:
      - !ReverseTunnel
        protocol:
          - Unix
          - Tcp
        port:
          - 8000..9000
        cidr:
          - "127.0.0.0/8"
          - "::1/128"
        # Sockets must be in a directory named after the device CN
        # Example: CN "device001" → /tmp/device001/app.sock, /tmp/device001/service.sock
        unix_path: "^/tmp/${cn}/.*\\.sock$"

---
restrictions:
  # Multi-tenant isolation
  - name: "Tenant-specific tunnel isolation"
    description: "Each tenant (identified by certificate CN) gets isolated tunnel access"
    match:
      - !Any
    allow:
      - !ReverseTunnel
        protocol:
          - Unix
          - Tcp
          - Udp
        port:
          - 10000..20000
        cidr:
          - "10.0.0.0/8"  # Private network only
        # Tenant-specific Unix socket path
        # Example: CN "tenant-acme" → /var/run/tenants/tenant-acme/service.sock
        unix_path: "^/var/run/tenants/${cn}/.*\\.sock$"
      - !Tunnel
        # Allow outbound tunnels matching tenant pattern
        host: "^${cn}-.*\\.internal\\.example\\.com$"
        port:
          - 443
          - 8443
        cidr:
          - "10.0.0.0/8"

---
restrictions:
  # IoT device fleet management
  - name: "IoT sensor fleet with CN-based routing"
    description: "Each IoT sensor device connects to its own dedicated Unix socket"
    match:
      # Optional: Could require specific authorization token
      # - !Authorization "^Bearer [A-Za-z0-9-_\\.]+$"
      - !Any
    allow:
      - !ReverseTunnel
        protocol:
          - Unix
        # Each sensor gets isolated access to its own socket
        # Example: CN "sensor-temperature-01" → /opt/iot/sensors/sensor-temperature-01.sock
        # Example: CN "sensor-motion-05" → /opt/iot/sensors/sensor-motion-05.sock
        unix_path: "^/opt/iot/sensors/${cn}\\.sock$"

---
# Certificate Variables Reference:
# Currently supported:
#   ${cn} or ${cert.cn} - Common Name from certificate subject
#
# Planned for future releases:
#   ${cert.subject.ou} - Organizational Unit
#   ${cert.subject.o}  - Organization
#   ${cert.serial}     - Certificate serial number
#
# Benefits:
# - Zero-touch provisioning: New devices automatically get appropriate access
# - Scalability: One rule handles unlimited devices
# - Security: Directly ties mTLS authentication to authorization
# - Maintainability: Clean, simple configuration
